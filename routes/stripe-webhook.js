const express = require("express");
const router = express.Router();
const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);
const Customer = require("../models/Customer");
const Order = require("../models/Order");
// Importer le module d'envoi d'email AVEC LA NOUVELLE FONCTION
const { sendOrderConfirmation, sendOrderNotificationToAdmin } = require("../modules/emailSender");

// Route sp√©ciale pour tester l'envoi d'email manuellement
router.get("/test-email/:orderId", async (req, res) => {
  try {
    const orderId = req.params.orderId;
    console.log(`üîç Test d'envoi d'email pour la commande ${orderId}`);
    
    // Trouver la commande
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).send("Commande non trouv√©e");
    }
    
    // Trouver le client associ√©
    const customer = await Customer.findById(order.customer);
    if (!customer) {
      return res.status(404).send("Client non trouv√©");
    }
    
    // Envoyer les emails (client + admin)
    await sendOrderConfirmation(customer, order);
    await sendOrderNotificationToAdmin(customer, order);
    
    res.send("Emails de test envoy√©s avec succ√®s (client + admin)");
  } catch (error) {
    console.error("Erreur lors de l'envoi des emails de test:", error);
    res.status(500).send(`Erreur: ${error.message}`);
  }
});

// Route pour les tests - garde-la pendant que tu d√©veloppes
router.post("/webhook-test", express.json(), async (req, res) => {
  console.log("üìå Webhook TEST re√ßu");
  
  const event = req.body;
  
  if (event.type === "checkout.session.completed") {
    const session = event.data.object;
    console.log(`üîÑ Traitement de la session de test: ${session.id}`);

    try {
      if (session.payment_status !== 'paid') {
        console.log(`‚ö†Ô∏è Paiement non compl√©t√©. Statut: ${session.payment_status}`);
        return res.status(200).send("Webhook re√ßu, paiement non compl√©t√©.");
      }

      const { customer_email } = session;
      
      if (!session.metadata) {
        console.error("‚ùå Aucune m√©tadonn√©e trouv√©e dans la session");
        return res.status(200).send("Webhook re√ßu, mais m√©tadonn√©es manquantes.");
      }

      const { 
        items, 
        totalAmount, 
        firstName, 
        lastName, 
        phone, 
        address, 
        city, 
        postalCode, 
        country,
        shippingMethod
      } = session.metadata;

      console.log(`üìã M√©tadonn√©es re√ßues:`, session.metadata);

      let customer = await Customer.findOne({ email: customer_email });

      if (!customer) {
        customer = new Customer({
          firstName,
          lastName,
          email: customer_email,
          phone,
          address,
          city,
          postalCode,
          country,
        });
        await customer.save();
        console.log(`‚úÖ Nouveau client cr√©√© avec l'ID: ${customer._id}`);
      } else {
        console.log(`üîÑ Client existant trouv√© avec l'ID: ${customer._id}`);
      }

      let parsedItems;
      try {
        parsedItems = JSON.parse(items);
        console.log(`üì¶ Articles pars√©s: ${parsedItems.length} articles`);
      } catch (parseError) {
        console.error("‚ùå Erreur lors du parsing des articles:", parseError);
        return res.status(200).send("Webhook re√ßu, erreur de parsing des articles.");
      }

      const newOrder = new Order({
        customer: customer._id,
        items: parsedItems,
        totalAmount: parseFloat(totalAmount),
        status: "processing",
        payment: "completed", // Marquer le paiement comme compl√©t√©
        sessionId: session.id,
        shippingMethod,
        shippingCost: 0,
      });
      
      await newOrder.save();
      console.log(`‚úÖ Nouvelle commande cr√©√©e avec l'ID: ${newOrder._id}`);

      customer.orders.push(newOrder._id);
      await customer.save();
      console.log(`üîÑ Commande associ√©e au client avec succ√®s`);

      // === NOUVELLE SECTION : ENVOI DES EMAILS ===
      console.log("\nüìß === D√âBUT ENVOI DES EMAILS ===");
      
      // 1. Envoyer l'email de confirmation au CLIENT
      try {
        console.log(`üìß Envoi de l'email de confirmation au client: ${customer.email}`);
        await sendOrderConfirmation(customer, newOrder);
        console.log(`‚úâÔ∏è ‚úÖ Email de confirmation envoy√© avec succ√®s au client: ${customer.email}`);
      } catch (emailError) {
        console.error("‚ùå Erreur lors de l'envoi de l'email de confirmation au client:", emailError.message);
        // On continue m√™me si l'email √©choue pour ne pas bloquer la commande
      }

      // 2. NOUVEAU : Envoyer la notification √† L'ADMIN (contact@monsavonvert.com)
      try {
        console.log(`üö® Envoi de la notification admin pour la commande #${newOrder.orderNumber || newOrder._id}`);
        await sendOrderNotificationToAdmin(customer, newOrder);
        console.log(`‚úâÔ∏è ‚úÖ Notification admin envoy√©e avec succ√®s √†: contact@monsavonvert.com`);
      } catch (adminEmailError) {
        console.error("‚ùå Erreur lors de l'envoi de la notification admin:", adminEmailError.message);
        // On continue m√™me si l'email admin √©choue pour ne pas bloquer la commande
      }
      
      console.log("üìß === FIN ENVOI DES EMAILS ===\n");

      console.log("‚úÖ Client et commande enregistr√©s avec succ√®s.");
    } catch (error) {
      console.error("‚ùå Erreur lors de l'enregistrement du client ou de la commande:", error);
      return res.status(200).send("Webhook re√ßu, erreur de traitement interne.");
    }
  }

  console.log("üì¨ R√©ponse 200 envoy√©e");
  res.status(200).send("Webhook de test re√ßu et trait√© avec succ√®s.");
});

// Route de production - cette route sera appel√©e par Stripe, pas par ton frontend
// ATTENTION: Changer le format de la route pour passer le contenu brut correctement
router.post("/webhook", express.raw({ type: "application/json" }), async (req, res) => {
  // Pour le d√©veloppement/test, si pas de signature, on traite quand m√™me
  const sig = req.headers["stripe-signature"];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET || 'whsec_test'; // Utilise une valeur par d√©faut si pas de secret configur√©
  
  console.log("üìå Webhook Stripe re√ßu - V√âRIFICATION");
  
  let event;
  
  try {
    // Si on a une signature et un secret, on v√©rifie
    if (sig && endpointSecret && endpointSecret !== 'whsec_test') {
      event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
      console.log(`‚úÖ √âv√©nement Stripe v√©rifi√©: ${event.type}`);
    } else {
      // Sinon, on prend le body tel quel (mode d√©veloppement)
      event = JSON.parse(req.body.toString());
      console.log(`‚ö†Ô∏è Mode d√©veloppement: signature non v√©rifi√©e`);
    }

    // IMPORTANT: Logger l'√©v√©nement pour le d√©bogage
    console.log("üìã √âv√©nement re√ßu:", JSON.stringify(event, null, 2));
  } catch (err) {
    console.error("‚ùå Erreur lors du traitement du webhook:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // G√©rer l'√©v√©nement `checkout.session.completed`
  if (event.type === "checkout.session.completed") {
    const session = event.data.object;
    console.log(`üîÑ Traitement de la session de paiement: ${session.id}`);

    try {
      // V√©rifier que le paiement est bien r√©ussi
      if (session.payment_status !== 'paid') {
        console.log(`‚ö†Ô∏è Paiement non compl√©t√© pour la session ${session.id}. Statut: ${session.payment_status}`);
        return res.status(200).send("Webhook re√ßu, paiement non compl√©t√©.");
      }

      // R√©cup√©rer les informations du client et de la commande
      const { customer_email } = session;
      
      // V√©rifier que les m√©tadonn√©es existent
      if (!session.metadata) {
        console.error("‚ùå Aucune m√©tadonn√©e trouv√©e dans la session");
        return res.status(200).send("Webhook re√ßu, mais m√©tadonn√©es manquantes.");
      }

      const { 
        items, 
        totalAmount, 
        firstName, 
        lastName, 
        phone, 
        address, 
        city, 
        postalCode, 
        country,
        shippingMethod
      } = session.metadata;

      // V√©rifier si le client existe d√©j√†
      console.log(`üîç Recherche du client avec l'email: ${customer_email}`);
      let customer = await Customer.findOne({ email: customer_email });

      if (!customer) {
        // Cr√©er un nouveau client
        console.log(`‚ú® Cr√©ation d'un nouveau client: ${firstName} ${lastName}`);
        customer = new Customer({
          firstName,
          lastName,
          email: customer_email,
          phone,
          address,
          city,
          postalCode,
          country,
        });
        await customer.save();
        console.log(`‚úÖ Nouveau client cr√©√© avec l'ID: ${customer._id}`);
      } else {
        console.log(`üîÑ Client existant trouv√© avec l'ID: ${customer._id}`);
      }

      // Parsing des items avec gestion d'erreur
      let parsedItems;
      try {
        parsedItems = JSON.parse(items);
        console.log(`üì¶ Articles pars√©s: ${parsedItems.length} articles`);
      } catch (parseError) {
        console.error("‚ùå Erreur lors du parsing des articles:", parseError);
        return res.status(200).send("Webhook re√ßu, erreur de parsing des articles.");
      }

      // Cr√©er une nouvelle commande associ√©e au client
      const newOrder = new Order({
        customer: customer._id,
        items: parsedItems,
        totalAmount: parseFloat(totalAmount),
        status: "processing",
        payment: "completed", // Marquer le paiement comme compl√©t√©
        sessionId: session.id,
        shippingMethod,
        shippingCost: session.shipping_cost ? session.shipping_cost.amount_total / 100 : 0,
      });
      
      await newOrder.save();
      console.log(`‚úÖ Nouvelle commande cr√©√©e avec l'ID: ${newOrder._id}`);

      // Associer la commande au client
      customer.orders.push(newOrder._id);
      await customer.save();
      console.log(`üîÑ Commande associ√©e au client avec succ√®s`);

      // === NOUVELLE SECTION : ENVOI DES EMAILS ===
      console.log("\nüìß === D√âBUT ENVOI DES EMAILS ===");
      
      // 1. Envoyer l'email de confirmation au CLIENT
      try {
        console.log(`üìß Envoi de l'email de confirmation au client: ${customer.email}`);
        await sendOrderConfirmation(customer, newOrder);
        console.log(`‚úâÔ∏è ‚úÖ Email de confirmation envoy√© avec succ√®s au client: ${customer.email}`);
      } catch (emailError) {
        console.error("‚ùå Erreur lors de l'envoi de l'email de confirmation au client:", emailError.message);
        console.error("D√©tail de l'erreur client:", emailError.stack);
        // On continue m√™me si l'email client √©choue
      }

      // 2. NOUVEAU : Envoyer la notification √† L'ADMIN (contact@monsavonvert.com)
      try {
        console.log(`üö® Envoi de la notification admin pour la commande #${newOrder.orderNumber || newOrder._id}`);
        await sendOrderNotificationToAdmin(customer, newOrder);
        console.log(`‚úâÔ∏è ‚úÖ Notification admin envoy√©e avec succ√®s √†: contact@monsavonvert.com`);
      } catch (adminEmailError) {
        console.error("‚ùå ERREUR IMPORTANTE lors de l'envoi de la notification admin:", adminEmailError.message);
        console.error("D√©tail de l'erreur admin:", adminEmailError.stack);
        // On continue m√™me si l'email admin √©choue pour ne pas bloquer la commande
      }
      
      console.log("üìß === FIN ENVOI DES EMAILS ===\n");

      console.log("‚úÖ Client et commande enregistr√©s avec succ√®s.");
    } catch (error) {
      console.error("‚ùå Erreur lors de l'enregistrement du client ou de la commande:", error);
      // Ne pas √©chouer le webhook m√™me en cas d'erreur de traitement
      return res.status(200).send("Webhook re√ßu, erreur de traitement interne.");
    }
  }

  // Toujours renvoyer un succ√®s pour les webhooks Stripe
  console.log("üì¨ R√©ponse 200 envoy√©e √† Stripe");
  res.status(200).send("Webhook re√ßu et trait√© avec succ√®s.");
});

// Route de test pour envoyer un email manuellement
router.get("/test-email-simple", async (req, res) => {
  try {
    console.log('üß™ Test d\'envoi d\'email simple');
    
    // Cr√©er un client et une commande factices pour le test
    const testCustomer = {
      firstName: 'Test',
      lastName: 'Client', 
      email: 'yanlry.mongo@gmail.com' // Ton email v√©rifi√©
    };
    
    const testOrder = {
      _id: 'TEST123456789',
      orderNumber: 'TEST-001',
      items: [
        {
          name: 'Test Savon',
          price: 10.99,
          quantity: 2
        }
      ],
      totalAmount: 21.98,
      createdAt: new Date()
    };
    
    // Envoyer TOUS les emails de test
    console.log('üìß Envoi de l\'email de confirmation client...');
    await sendOrderConfirmation(testCustomer, testOrder);
    
    console.log('üö® Envoi de la notification admin...');
    await sendOrderNotificationToAdmin(testCustomer, testOrder);
    
    res.json({
      success: true,
      message: 'Emails de test envoy√©s avec succ√®s !',
      details: {
        clientEmail: testCustomer.email,
        adminEmail: 'contact@monsavonvert.com',
        orderNumber: testOrder.orderNumber
      }
    });
  } catch (error) {
    console.error('Erreur lors de l\'envoi des emails de test:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// NOUVELLE ROUTE : Test sp√©cifique de la notification admin
router.get("/test-admin-notification", async (req, res) => {
  try {
    console.log('üö® Test sp√©cifique de la notification admin');
    
    // Cr√©er un client et une commande factices pour le test
    const testCustomer = {
      _id: 'test-customer-id',
      firstName: 'Jean',
      lastName: 'Dupont', 
      email: 'jean.dupont@email.com',
      phone: '0123456789'
    };
    
    const testOrder = {
      _id: 'test-order-id',
      orderNumber: 'CMD-2024-001',
      items: [
        {
          name: 'Savon √† l\'huile d\'olive',
          price: 8.50,
          quantity: 3
        },
        {
          name: 'Savon au miel et avoine',
          price: 9.99,
          quantity: 1
        }
      ],
      totalAmount: 35.49,
      createdAt: new Date(),
      shippingAddress: {
        name: 'Jean Dupont',
        line1: '123 Rue de la Paix',
        city: 'Paris',
        postal_code: '75001',
        country: 'France'
      }
    };
    
    // Envoyer UNIQUEMENT la notification admin
    console.log('üö® Envoi de la notification admin...');
    await sendOrderNotificationToAdmin(testCustomer, testOrder);
    
    res.json({
      success: true,
      message: 'Notification admin envoy√©e avec succ√®s !',
      details: {
        adminEmail: 'contact@monsavonvert.com',
        customerEmail: testCustomer.email,
        orderNumber: testOrder.orderNumber,
        totalAmount: testOrder.totalAmount
      }
    });
  } catch (error) {
    console.error('Erreur lors de l\'envoi de la notification admin:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      stack: error.stack
    });
  }
});

module.exports = router;